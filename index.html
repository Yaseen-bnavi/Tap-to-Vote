<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>Supreme Strategic Campaign Simulator (Iraq)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --tg-theme-bg-color: #0f172a;
            --tg-theme-text-color: #f1f5f9;
        }
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--tg-theme-bg-color) 0%, #1e293b 70%, var(--tg-theme-bg-color) 100%);
            color: var(--tg-theme-text-color);
            overscroll-behavior-y: contain;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .tap-feedback {
            position: absolute; font-size: 2.2rem; font-weight: 900;
            color: #fcd34d; text-shadow: 0 2px 8px #000;
            pointer-events: none; animation: floatup 0.9s ease-out forwards;
            white-space: nowrap; z-index: 100;
        }
        @keyframes floatup {
            0% { transform: translateY(0) scale(1.2); opacity: 1; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }
        #tapButton {
            width: 230px; height: 230px;
            background: radial-gradient(circle at center, #3b82f6 0%, #1e40af 70%, #1e3a8a 100%);
            border: 6px solid #fef3c7;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.9);
            box-shadow: 0 15px 40px rgba(37, 99, 235, 0.7), 0 0 0 15px rgba(254, 243, 199, 0.2);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            touch-action: manipulation;
        }
        #tapButton.boost-active { animation: boostPulse 1s infinite; }
        @keyframes boostPulse {
            50% { box-shadow: 0 20px 60px rgba(59, 130, 246, 0.9), 0 0 0 20px rgba(254, 243, 199, 0.5); }
        }
        #tapButton:active { transform: scale(0.95); }
        .nav-item.active { color: #3b82f6; background-color: #1e293b; }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1001; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 1000; }
        .hide { display: none; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
    </style>
</head>
<body class="text-slate-100 p-4 pb-24 max-w-lg mx-auto min-h-screen">

    <div id="loadingIndicator" class="fixed inset-0 bg-gray-900/90 z-[2000] flex justify-center items-center">
        <!-- Loading spinner content remains the same -->
    </div>

    <div id="messageBox" class="fixed bottom-24 left-1/2 -translate-x-1/2 w-[90%] max-w-md z-[100]"></div>
    
    <button id="adminToggle" class="fixed top-4 right-4 z-50 bg-blue-600 text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg"><i class="fa fa-cog"></i></button>

    <header id="header" class="w-full mb-4 p-4 bg-slate-800/80 rounded-xl shadow-2xl border border-slate-700/50 sticky top-4 z-30">
        <!-- Header content will be dynamically rendered by JS -->
    </header>

    <main class="w-full flex-grow">
        <div id="tap" class="tab-content fade-in"></div>
        <div id="cards" class="tab-content hide"></div>
        <div id="missions" class="tab-content hide"></div>
        <div id="media" class="tab-content hide"></div>
        <div id="party" class="tab-content hide"></div>
        <div id="store" class="tab-content hide"></div>
        <div id="leaderboard" class="tab-content hide"></div>
    </main>

    <nav class="fixed bottom-0 left-0 right-0 max-w-lg mx-auto w-full flex justify-around p-2 border-t border-gray-700/50 rounded-t-xl z-40 bg-[#0f172a]">
        <!-- Nav items will be dynamically rendered by JS -->
    </nav>
    
    <div id="modalContainer"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONSTANTS & CONFIG ---
// **IMPROVEMENT**: Grouping constants for better organization.
const TCI_SCALING = { COINS: 10000, CARD_LEVEL: 10, PARTY_LEVEL: 50 };
const ENERGY_CONFIG = { MAX: 100, REGEN_RATE: 1 };
const GAME_TIMERS = { COMBO_TIMEOUT: 2000, SAVE_INTERVAL: 30000, MAIN_TICK: 1000 };
const STREAK_BONUS = [0, 5, 10, 15, 20, 25, 30, 40, 50, 75]; // Bonus in percentage
const DAILY_GOAL = { TAPS: 100, REWARD_COINS: 5000, REWARD_TOKENS: 1 };
const APP_VERSION = '1.2.0'; // **IMPROVEMENT**: Centralized version number.

// **IMPROVEMENT**: Using a more resilient and permanent link to the raw file.
const CONFIG_URLS = {
    parties: 'https://raw.githubusercontent.com/Yaseen-bnavi/Tap-to-Vote/main/config/parties.json',
    candidates: 'https://raw.githubusercontent.com/Yaseen-bnavi/Tap-to-Vote/main/config/candidates.json',
    managers: 'https://raw.githubusercontent.com/Yaseen-bnavi/Tap-to-Vote/main/config/managers.json'
};
// Admin contact information
const ADMIN_CONTACT = {
    telegram: '@campaign_admin',
    email: 'admin@campaign.com',
    phone: '+964 XXX XXX XXXX',
    instructions: 'Contact us to activate your candidate or party card. Payment required for activation services.',
    pricing: {
        candidate: '50,000 IQD per month',
        party: '100,000 IQD per month',
        sponsorship: '200,000 IQD per month'
    }
};

// **IMPROVEMENT**: More descriptive achievement structure.
const ACHIEVEMENTS = [
    { id: 'taps1', type: 'totalTaps', threshold: 100, title: "First Steps", description: "Reach 100 total taps", reward: 1000 },
    { id: 'taps2', type: 'totalTaps', threshold: 1000, title: "Dedicated Campaigner", description: "Reach 1,000 total taps", reward: 5000 },
    { id: 'coins1', type: 'totalLifetimeCoins', threshold: 10000, title: "Wealthy Backer", description: "Accumulate 10,000 coins", reward: 2000 },
    { id: 'cards1', type: 'userCards', threshold: 3, title: "Building a Team", description: "Own 3 candidate cards", reward: 1 }, // reward is tokens
];

const DAILY_MISSIONS = [
    { id: 1, type: 'dailyTaps', target: 50, reward: 1000, title: "Tap 50 Times", description: "Basic tapping mission" },
    { id: 2, type: 'dailyTaps', target: 200, reward: 5000, title: "Tap 200 Times", description: "Advanced tapping mission" },
    { id: 3, type: 'coinsEarnedToday', target: 10000, reward: 2000, title: "Earn 10,000 Funds", description: "Wealth accumulation" },
    { id: 4, type: 'cardLevel', target: 3, reward: 3000, title: "Upgrade a Card to Lv.3", description: "Strengthen your team" },
];

const BOOSTS = [
    { id: 'boost_2x', name: "2x Multiplier", duration: 60, cost: 5000, multiplier: 2, icon: '‚ö°' },
    { id: 'boost_energy', name: "Energy Refill", duration: 0, cost: 3000, energy: 50, icon: 'üîã' },
];

let GAME_CONFIG = { parties: {}, candidates: [], managers: [] };

// --- GAME STATE ---
let gameState;
let activeTab = 'tap';
let messageTimeout;
let telegramUser = null;

// --- UTILS ---
const formatNumber = (num) => {
  if (isNaN(num) || num === null) return '0';
  if (num >= 1_000_000) return `${(num / 1_000_000).toFixed(1)}M`;
  if (num >= 1_000) return `${(num / 1_000).toFixed(1)}K`;
  return Math.floor(num).toString();
};

const getTodayString = () => new Date().toISOString().split('T')[0];

const showMessage = (text, type = 'info') => {
    const messageBox = document.getElementById('messageBox');
    if (!messageBox) return;
    clearTimeout(messageTimeout);
    const colors = {
        success: 'bg-green-600',
        error: 'bg-red-600',
        info: 'bg-blue-600'
    };
    const color = colors[type] || colors.info;
    messageBox.innerHTML = `<div class="${color} text-white text-center font-bold p-3 rounded-lg shadow-lg animate-pulse">${text}</div>`;
    messageTimeout = setTimeout(() => { messageBox.innerHTML = ''; }, 3000);
};

// **IMPROVEMENT**: Centralized DOM element selection to avoid repeated lookups.
const DOM_ELEMENTS = {
    loadingIndicator: document.getElementById('loadingIndicator'),
    header: document.getElementById('header'),
    nav: document.querySelector('nav'),
    modalContainer: document.getElementById('modalContainer'),
    adminToggle: document.getElementById('adminToggle'),
    tabs: {
        tap: document.getElementById('tap'),
        cards: document.getElementById('cards'),
        missions: document.getElementById('missions'),
        media: document.getElementById('media'),
        party: document.getElementById('party'),
        store: document.getElementById('store'),
        leaderboard: document.getElementById('leaderboard')
    }
};

// --- CONFIG LOADING ---
const loadExternalConfig = async () => {
    // Logic is solid, keeping it as is with minor logging improvements.
    try {
        console.log('Loading external configuration...');
        const persistedConfig = JSON.parse(localStorage.getItem('campaignConfig') || 'null');
        
        const fetchAndMerge = async (url, key) => {
            const response = await fetch(`${url}?v=${Date.now()}`); // **IMPROVEMENT**: Cache-busting
            if (!response.ok) throw new Error(`Failed to load ${key}: ${response.status}`);
            const freshData = await response.json();
            GAME_CONFIG[key] = persistedConfig ? mergeConfigs(freshData, persistedConfig[key], key) : freshData;
            console.log(`‚úÖ ${key} config loaded.`);
        };
        
        await Promise.all([
            fetchAndMerge(CONFIG_URLS.parties, 'parties'),
            fetchAndMerge(CONFIG_URLS.candidates, 'candidates'),
            fetchAndMerge(CONFIG_URLS.managers, 'managers')
        ]);
        
        console.log('üéâ All external config loaded successfully!');
    } catch (error) {
        console.error('‚ùå Error loading external config:', error);
        // Fallback logic remains the same, it's a good safeguard.
    }
};

const mergeConfigs = (fresh, persisted, type) => {
    if (!persisted) return fresh;
    if (type === 'candidates') {
        return fresh.map(freshItem => ({
            ...freshItem,
            ...(persisted.find(p => p.id === freshItem.id) || {})
        }));
    }
    if (type === 'parties') {
        Object.keys(fresh).forEach(key => {
            if (persisted[key]) {
                fresh[key].active = persisted[key].active;
            }
        });
        return fresh;
    }
    return fresh;
};

const saveConfigChanges = () => {
    try {
        const configToSave = {
            parties: GAME_CONFIG.parties,
            candidates: GAME_CONFIG.candidates.map(c => ({ id: c.id, active: c.active, sponsored: c.sponsored })),
            managers: GAME_CONFIG.managers
        };
        localStorage.setItem('campaignConfig', JSON.stringify(configToSave));
        console.log('‚úÖ Config changes saved to localStorage');
    } catch (e) {
        console.error('‚ùå Could not save config changes to localStorage', e);
    }
};

// --- CORE LOGIC ---
const calculatePPH = (state) => {
    if (!state?.userCards) return 0;
    const totalPPH = state.userCards.reduce((acc, card) => {
        if (!card.activated) return acc;
        const candidate = GAME_CONFIG.candidates.find(c => c.id === card.id);
        if (!candidate) return acc;
        
        let profit = candidate.profitPerHour * card.level;
        const managerMultiplier = state.managerCards.reduce((mult, managerId) => {
            const manager = GAME_CONFIG.managers.find(m => m.id === managerId);
            return mult * (manager?.effect || 1);
        }, 1);
        
        return acc + (profit * managerMultiplier);
    }, 0);
    return Math.floor(totalPPH);
};

const calculateTCI = (state) => {
    if (!state) return 0;
    const coinsTCI = (state.totalLifetimeCoins || 0) / TCI_SCALING.COINS;
    const cardsTCI = (state.userCards?.reduce((acc, card) => acc + card.level, 0) || 0) * TCI_SCALING.CARD_LEVEL;
    const partiesTCI = (Object.values(state.parties)?.reduce((acc, party) => acc + party.level, 0) || 0) * TCI_SCALING.PARTY_LEVEL;
    return Math.floor(coinsTCI + cardsTCI + partiesTCI);
};

const calculateTapPower = (state) => {
    if (!state) return 1;
    let basePower = 1 + (state.userCards?.reduce((acc, card) => {
        if (!card.activated) return acc;
        const c = GAME_CONFIG.candidates.find(c => c.id === card.id);
        return acc + (c ? c.baseBonus * card.level : 0);
    }, 0) || 0);
    
    let partyMultiplier = 1; // Simplified for now
    const boostMultiplier = state.activeBoosts?.reduce((acc, b) => acc * (b.multiplier || 1), 1) || 1;
    const streakBonus = 1 + (STREAK_BONUS[state.streak || 0] / 100);

    return Math.floor(basePower * partyMultiplier * boostMultiplier * streakBonus);
};

// --- STATE MANAGEMENT ---
const saveGameState = () => {
    if(!gameState) return;
    try {
        gameState.lastPlayTime = Date.now();
        localStorage.setItem('campaignSimulatorSave', JSON.stringify(gameState));
    } catch (e) {
        console.warn("Could not save game state.", e);
    }
};

const createDefaultGameState = () => ({
    coins: 1000, influenceTokens: 0, dailyTaps: 0, totalTaps: 0,
    totalLifetimeCoins: 1000, coinsEarnedToday: 0, userCards: [],
    parties: Object.keys(GAME_CONFIG.parties).reduce((acc, partyId) => {
        acc[partyId] = { id: partyId, level: 1, xp: 0 }; return acc;
    }, {}),
    lastDailyRewardDate: null, 
    userId: 'user_' + Date.now().toString(36),
    watchedVideos: {}, managerCards: [], lastPlayTime: Date.now(),
    achievements: [], energy: ENERGY_CONFIG.MAX, lastEnergyUpdate: Date.now(),
    combo: 0, lastTapTime: 0, streak: 1,
    lastLoginDate: getTodayString(), activeBoosts: [], completedMissions: [],
    missionProgress: DAILY_MISSIONS.reduce((acc, m) => { acc[m.id] = { progress: 0 }; return acc; }, {}),
    telegram: { id: null, username: null, firstName: null, lastName: null },
    appVersion: APP_VERSION
});

const loadGameState = () => {
    let savedStateJSON;
    try {
        savedStateJSON = localStorage.getItem('campaignSimulatorSave');
    } catch (e) { console.warn("localStorage is unavailable.", e); }

    const defaultState = createDefaultGameState();
    let initialState = defaultState;
    if (savedStateJSON) {
        try {
            initialState = { ...defaultState, ...JSON.parse(savedStateJSON) };
        } catch (e) { console.error("Failed to parse saved state.", e); }
    }
    
    // Offline earnings
    const timeOfflineHours = (Date.now() - initialState.lastPlayTime) / 3600000;
    const pph = calculatePPH(initialState);
    const offlineEarnings = Math.min(Math.floor(pph * timeOfflineHours), pph * 24); // Cap at 24 hours
    if (offlineEarnings > 0) {
        initialState.coins += offlineEarnings;
        initialState.totalLifetimeCoins += offlineEarnings;
        setTimeout(() => showMessage(`Welcome back! You earned ${formatNumber(offlineEarnings)} üí∞ offline.`, 'success'), 1500);
    }
    
    // Daily reset logic
    const today = getTodayString();
    if (initialState.lastLoginDate !== today) {
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        initialState.streak = initialState.lastLoginDate === yesterday.toISOString().split('T')[0]
            ? Math.min(initialState.streak + 1, STREAK_BONUS.length - 1)
            : 1;
        initialState.lastLoginDate = today;
        initialState.dailyTaps = 0;
        initialState.coinsEarnedToday = 0;
        initialState.completedMissions = [];
        initialState.missionProgress = DAILY_MISSIONS.reduce((acc, m) => { acc[m.id] = { progress: 0 }; return acc; }, {});
    }

    gameState = initialState;
    gameState.appVersion = APP_VERSION;
};

// --- GAME LOOP & UPDATES ---
const mainTick = () => {
    if (!gameState) return;
    const now = Date.now();
    
    // Regenerate energy
    const timePassed = (now - gameState.lastEnergyUpdate) / 1000;
    const newEnergy = Math.min(ENERGY_CONFIG.MAX, gameState.energy + timePassed * ENERGY_CONFIG.REGEN_RATE);
    if (Math.floor(newEnergy) > Math.floor(gameState.energy)) {
        gameState.energy = newEnergy;
        updateEnergyBar();
    }
    gameState.lastEnergyUpdate = now;

    // Check for expired boosts
    const activeBoosts = gameState.activeBoosts.filter(b => b.endTime > now);
    if (activeBoosts.length !== gameState.activeBoosts.length) {
        gameState.activeBoosts = activeBoosts;
        updateTapScreen(); // Recalculate tap power visual
    }
};

const updateAllUI = () => {
    updateHeader();
    renderCurrentTab();
};

const checkAchievements = () => {
    ACHIEVEMENTS.forEach(ach => {
        if (gameState.achievements.includes(ach.id)) return;
        
        let conditionMet = false;
        if (ach.type === 'userCards' && gameState.userCards.length >= ach.threshold) conditionMet = true;
        else if (gameState[ach.type] >= ach.threshold) conditionMet = true;

        if (conditionMet) {
            gameState.achievements.push(ach.id);
            if (ach.reward > 100) gameState.coins += ach.reward; else gameState.influenceTokens += ach.reward;
            const content = `<div class="text-center"><div class="text-6xl mb-2">üèÜ</div><p class="text-gray-300">${ach.description}</p><p class="font-bold text-yellow-400 mt-2">+${formatNumber(ach.reward)} ${ach.reward > 100 ? 'üí∞' : 'üíé'}</p></div>`;
            renderModal(`Achievement: ${ach.title}`, content);
        }
    });
};

// --- EVENT HANDLERS ---
const handleTap = (e) => {
    e.preventDefault();
    if (gameState.energy < 1) return;

    const now = Date.now();
    gameState.energy -= 1;
    
    gameState.combo = (now - gameState.lastTapTime < GAME_TIMERS.COMBO_TIMEOUT) ? gameState.combo + 1 : 1;
    gameState.lastTapTime = now;
    
    const tapValue = calculateTapPower(gameState);

    // Visual feedback
    const { clientX, clientY } = e.touches ? e.touches[0] : e;
    const feedback = document.createElement('div');
    feedback.className = 'tap-feedback';
    feedback.textContent = `+${formatNumber(tapValue)}`;
    feedback.style.left = `${clientX - 25}px`;
    feedback.style.top = `${clientY - 45}px`;
    document.body.appendChild(feedback);
    setTimeout(() => feedback.remove(), 900);

    // Update state
    gameState.coins += tapValue;
    gameState.totalTaps += 1;
    gameState.dailyTaps += 1;
    gameState.coinsEarnedToday += tapValue;
    gameState.totalLifetimeCoins += tapValue;
    
    // Check progress
    checkMissionProgress('dailyTaps', 1);
    checkMissionProgress('coinsEarnedToday', tapValue);
    
    if (gameState.dailyTaps === DAILY_GOAL.TAPS && getTodayString() !== gameState.lastDailyRewardDate) {
        gameState.coins += DAILY_GOAL.REWARD_COINS;
        gameState.influenceTokens += DAILY_GOAL.REWARD_TOKENS;
        gameState.lastDailyRewardDate = getTodayString();
        showMessage(`Daily Goal! +${formatNumber(DAILY_GOAL.REWARD_COINS)}üí∞ & +${DAILY_GOAL.REWARD_TOKENS}üíé`, 'success');
    }
    
    checkAchievements();
    
    // **IMPROVEMENT**: More targeted UI updates for better performance.
    updateCoinDisplay();
    updateEnergyBar();
    updateTapScreen();
};

const checkMissionProgress = (type, value) => {
    let missionCompleted = false;
    DAILY_MISSIONS.forEach(mission => {
        if (gameState.completedMissions.includes(mission.id)) return;
        
        const progress = gameState.missionProgress[mission.id];
        let completed = false;

        if (mission.type === type) {
            progress.progress = (progress.progress || 0) + value;
            if (progress.progress >= mission.target) completed = true;
        } else if (mission.type === 'cardLevel' && type === 'cardLevel') {
             if (value >= mission.target) completed = true;
        }
        
        if(completed) {
            gameState.completedMissions.push(mission.id);
            gameState.coins += mission.reward;
            gameState.totalLifetimeCoins += mission.reward;
            showMessage(`Mission Complete: ${mission.title}! +${formatNumber(mission.reward)}üí∞`, 'success');
            missionCompleted = true;
        }
    });
    if (missionCompleted && activeTab === 'missions') renderMissionsScreen();
};

// --- RENDER FUNCTIONS ---
// **IMPROVEMENT**: Split monolithic rendering into smaller, manageable functions.
const navigate = (tabName) => {
    if (activeTab === tabName) return;
    activeTab = tabName;
    
    Object.values(DOM_ELEMENTS.tabs).forEach(el => el.classList.add('hide'));
    const currentTabEl = DOM_ELEMENTS.tabs[tabName];
    if (currentTabEl) {
        currentTabEl.classList.remove('hide');
        currentTabEl.classList.add('fade-in');
    }
    
    renderNav();
    renderCurrentTab();
};

const renderCurrentTab = () => {
    const renderers = {
        tap: renderTapScreen, 
        cards: renderCardsScreen, 
        missions: renderMissionsScreen,
        media: renderMediaScreen, 
        party: renderPartyScreen, 
        store: renderStoreScreen,
        leaderboard: renderLeaderboardScreen,
    };
    if (renderers[activeTab]) renderers[activeTab]();
};

const updateCoinDisplay = () => {
    const coinsEl = document.getElementById('stat-coins');
    if (coinsEl) coinsEl.textContent = formatNumber(gameState.coins);
};

const updateEnergyBar = () => {
    const energyValEl = document.getElementById('stat-energy-val');
    const energyBarEl = document.getElementById('stat-energy-bar');
    if (energyValEl && energyBarEl) {
        const energyPercentage = (gameState.energy / ENERGY_CONFIG.MAX) * 100;
        energyValEl.textContent = `${Math.floor(gameState.energy)}/${ENERGY_CONFIG.MAX}`;
        energyBarEl.style.width = `${energyPercentage}%`;
    }
};

const renderHeader = () => {
    const pph = calculatePPH(gameState);
    const tci = calculateTCI(gameState);
    gameState.totalCampaignInfluence = tci; // Update state
    
    DOM_ELEMENTS.header.innerHTML = `
        <div class="flex justify-around text-center">
            <div><p id="stat-coins" class="text-2xl font-extrabold text-yellow-400">${formatNumber(gameState.coins)}</p><p class="text-xs text-gray-400">Funds üí∞</p></div>
            <div><p class="text-2xl font-extrabold text-purple-400">${formatNumber(gameState.influenceTokens)}</p><p class="text-xs text-gray-400">Tokens üíé</p></div>
            <div><p class="text-2xl font-extrabold text-green-400">${formatNumber(tci)}</p><p class="text-xs text-gray-400">Influence üìà</p></div>
        </div>
        <div class="bg-slate-900/50 rounded-lg p-2 mt-3">
            <div class="flex justify-between items-center text-sm mb-2 px-1">
                <div class="text-center"><p class="text-blue-400 font-bold" id="stat-tap-power">+${formatNumber(calculateTapPower(gameState))}</p><p class="text-gray-400 text-xs">Tap Power</p></div>
                <div class="text-center"><p class="text-green-400 font-bold">${formatNumber(pph)}/hr</p><p class="text-gray-400 text-xs">PPH</p></div>
                <div class="text-center"><p class="text-purple-400 font-bold">${gameState.userCards.filter(c=>c.activated).length}</p><p class="text-gray-400 text-xs">Active</p></div>
            </div>
            <div>
                <div class="flex justify-between text-xs mb-1 px-1"><span class="text-yellow-400 font-bold">‚ö° Energy</span><span id="stat-energy-val" class="text-gray-300">${Math.floor(gameState.energy)}/${ENERGY_CONFIG.MAX}</span></div>
                <div class="w-full h-2 bg-slate-700 rounded-full overflow-hidden"><div id="stat-energy-bar" class="h-full bg-yellow-400 transition-all duration-300" style="width: ${(gameState.energy / ENERGY_CONFIG.MAX) * 100}%"></div></div>
            </div>
        </div>
        <div id="combo-display" class="text-center font-bold text-lg text-yellow-300 mt-2 animate-pulse ${gameState.combo > 2 ? '' : 'hide'}">${gameState.combo}x Combo!</div>
    `;
};

const renderNav = () => {
    // Nav rendering logic is good.
    const navItems = [
        { tab: 'tap', icon: 'üëÜ', label: 'Tap' }, 
        { tab: 'cards', icon: 'üé¥', label: 'Cards' },
        { tab: 'missions', icon: 'üìã', label: 'Missions' }, 
        { tab: 'media', icon: 'üì∫', label: 'Media' },
        { tab: 'party', icon: 'üèõÔ∏è', label: 'Party' }, 
        { tab: 'store', icon: 'üíé', label: 'Store' },
        { tab: 'leaderboard', icon: 'üèÜ', label: 'Rank' },
    ];
    DOM_ELEMENTS.nav.innerHTML = navItems.map(({ tab, icon, label }) => `
        <button data-tab="${tab}" class="nav-item flex-1 flex flex-col items-center p-2 rounded-lg transition-colors ${activeTab === tab ? 'active' : 'text-gray-400'}">
            <span class="text-2xl">${icon}</span><span class="text-xs mt-1">${label}</span>
        </button>
    `).join('');
};

const updateTapScreen = () => {
    // **IMPROVEMENT**: This function now only updates the dynamic parts of the tap screen.
    const tapPowerEl = document.getElementById('stat-tap-power');
    const tapButtonPowerEl = document.getElementById('tapButton-power');
    const comboEl = document.getElementById('combo-display');
    const dailyProgress = document.getElementById('daily-progress-bar');
    
    const tapPower = calculateTapPower(gameState);
    if(tapPowerEl) tapPowerEl.textContent = `+${formatNumber(tapPower)}`;
    if(tapButtonPowerEl) tapButtonPowerEl.textContent = `+${formatNumber(tapPower)}`;
    
    if(comboEl) {
        if(gameState.combo > 2) {
            comboEl.textContent = `${gameState.combo}x Combo!`;
            comboEl.classList.remove('hide');
        } else {
            comboEl.classList.add('hide');
        }
    }
    
    if (dailyProgress) {
        const progressPercent = Math.min(100, (gameState.dailyTaps / DAILY_GOAL.TAPS) * 100);
        dailyProgress.style.width = `${progressPercent}%`;
    }
};

const renderTapScreen = () => {
    const isBoostActive = gameState.activeBoosts.some(b => b.multiplier > 1);
    const progressPercent = Math.min(100, (gameState.dailyTaps / DAILY_GOAL.TAPS) * 100);
    DOM_ELEMENTS.tabs.tap.innerHTML = `
        <div class="relative mb-8 mt-4">
            <button id="tapButton" class="w-[230px] h-[230px] rounded-full flex flex-col justify-center items-center text-white font-black text-4xl shadow-lg active:scale-95 transition-transform select-none ${isBoostActive ? 'boost-active' : ''}">
                Tap! <span id="tapButton-power" class="text-3xl mt-1">+${formatNumber(calculateTapPower(gameState))}</span>
            </button>
        </div>
        <div class="bg-gradient-to-r from-purple-600 to-indigo-600 rounded-xl p-3 w-full max-w-sm mb-4">
            <div class="flex justify-between items-center">
                <div><p class="font-bold text-lg">${gameState.streak} Day Streak</p><p class="text-xs text-yellow-300">Tap Power Bonus: +${STREAK_BONUS[gameState.streak]}%</p></div>
            </div>
        </div>
        <div class="w-full max-w-sm p-4 bg-slate-800/80 rounded-xl border border-slate-700/50">
            <h3 class="font-bold text-lg text-blue-300 mb-2">Daily Goal (${DAILY_GOAL.TAPS} Taps)</h3>
            <p class="text-sm text-gray-400 mb-2 flex justify-between">
                <span>Progress: ${gameState.dailyTaps}/${DAILY_GOAL.TAPS}</span>
                <span class="text-yellow-400">+${formatNumber(DAILY_GOAL.REWARD_COINS)}üí∞ & +${DAILY_GOAL.REWARD_TOKENS}üíé</span>
            </p>
            <div class="w-full bg-gray-700 rounded-full h-2.5"><div id="daily-progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: ${progressPercent}%"></div></div>
        </div>
    `;
};

const renderCardsScreen = () => {
    // This function is mostly static generation, so innerHTML is acceptable.
    DOM_ELEMENTS.tabs.cards.innerHTML = `
        <h2 class="text-2xl font-bold text-center mb-4 text-yellow-400">Candidate Cards</h2>
        <div class="space-y-4">${GAME_CONFIG.candidates.map(candidate => {
            const userCard = gameState.userCards.find(c => c.id === candidate.id);
            const cardClass = userCard ? (userCard.activated ? 'border-green-400 bg-slate-800' : 'border-slate-600 bg-slate-800/70') : 'border-slate-700 bg-slate-800/50';
            const upgradeCost = userCard ? candidate.bid * userCard.level * 1.5 : 0;
            return `
                <div class="p-4 rounded-xl border-2 relative ${cardClass}">
                    ${candidate.sponsored ? `<div class="absolute top-2 right-2 text-xs bg-yellow-500 text-black font-bold px-2 py-0.5 rounded-full">Sponsored</div>` : ''}
                    <div class="flex gap-4 items-start">
                        <img src="${candidate.photo}" alt="${candidate.name}" class="w-20 h-20 rounded-full object-cover border-4 ${candidate.logoColor}" />
                        <div class="flex-1">
                            <div class="flex justify-between"><h3 class="font-bold text-lg">${candidate.name}</h3>${userCard ? `<p class="font-bold text-yellow-400">Lv. ${userCard.level}</p>`: ''}</div>
                            <p class="text-sm text-gray-400">${GAME_CONFIG.parties[candidate.party]?.name || 'Unknown Party'}</p>
                            <p class="text-xs text-gray-300 mt-1">PPH: +${formatNumber(candidate.profitPerHour * (userCard ? userCard.level : 1))}</p>
                        </div>
                    </div>
                    <div class="flex justify-between mt-4 gap-2">
                        ${userCard ? `
                            <button data-action="toggleActivateCard" data-id="${candidate.id}" class="w-1/2 py-2 rounded font-bold text-white ${userCard.activated ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-green-600 hover:bg-green-500'}">${userCard.activated ? 'Deactivate' : 'Activate'}</button>
                            <button data-action="upgradeCard" data-id="${candidate.id}" class="w-1/2 bg-blue-600 hover:bg-blue-500 py-2 rounded font-bold text-white disabled:bg-gray-500 disabled:cursor-not-allowed" ${gameState.coins < upgradeCost ? 'disabled' : ''}>Upgrade (${formatNumber(upgradeCost)}üí∞)</button>
                        ` : `
                            <button data-action="buyCard" data-id="${candidate.id}" class="w-full bg-purple-600 hover:bg-purple-500 py-2 rounded font-bold text-white disabled:bg-gray-500 disabled:cursor-not-allowed" ${!candidate.active || gameState.coins < candidate.bid ? 'disabled' : ''}>${candidate.active ? `Buy (${formatNumber(candidate.bid)}üí∞)` : 'Unavailable'}</button>
                        `}
                    </div>
                    ${!candidate.active ? `<p class="text-xs text-red-400 mt-2">Card inactive. Contact admin: ${ADMIN_CONTACT.telegram}</p>` : ''}
                </div>`;
        }).join('')}</div>`;
};
// Other render functions (missions, media, etc.) can remain as they are, since they are less frequently updated.
const renderMissionsScreen = () => { /* Original code here */ };
const renderMediaScreen = () => { /* Original code here */ };
const renderPartyScreen = () => { /* Original code here */ };
const renderStoreScreen = () => { /* Original code here */ };
const renderLeaderboardScreen = () => { /* Original code here */ };

// --- MODAL & ADMIN ---
const renderModal = (title, content, showClose = true) => {
    DOM_ELEMENTS.modalContainer.innerHTML = `
        <div data-action="closeModal" class="modal-overlay"></div>
        <div class="modal bg-slate-800 w-[90%] max-w-lg rounded-xl p-6 border-2 border-blue-500 shadow-lg">
            <h2 class="text-2xl font-bold text-center mb-4 text-yellow-400">${title}</h2>
            <div>${content}</div>
            ${showClose ? `<button data-action="closeModal" class="w-full mt-6 bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 rounded">Close</button>` : ''}
        </div>`;
};

const closeModal = () => {
    DOM_ELEMENTS.modalContainer.innerHTML = '';
};
const renderAdminPanelContent = () => { /* Original code here */ };

// --- ACTION HANDLER ---
// Your action handler is well-structured. No major changes needed, just ensure it calls the right update functions.
const handleAction = (e) => {
    const target = e.target.closest('[data-action]');
    if (!target) return;
    const { action, id, type } = target.dataset;

    const performUpdate = () => {
        saveGameState();
        updateHeader(); // Always update header as coins might change
        renderCurrentTab();
    };

    // Actions like buyCard, upgradeCard, etc.
    if (action === 'buyCard') {
        // ... logic
        performUpdate();
    }
    // ... all other actions
    // For actions that only change a small part, call the specific updater.
    // e.g., toggleActivateCard would call `performUpdate()` because PPH and Active count changes.
};

// --- TELEGRAM INTEGRATION ---
const initTelegram = () => {
    if (window.Telegram?.WebApp) {
        const tg = window.Telegram.WebApp;
        tg.expand();
        telegramUser = tg.initDataUnsafe?.user;
        
        if (telegramUser) {
            console.log("Telegram user detected:", telegramUser);
            gameState.telegram = {
                id: telegramUser.id,
                username: telegramUser.username || `user_${telegramUser.id}`,
                firstName: telegramUser.first_name || '',
                lastName: telegramUser.last_name || ''
            };
        }
        
        if (tg.themeParams) {
            document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#0f172a');
            document.documentElement.style.setProperty('--tg-theme-text-color', tg.themeParams.text_color || '#f1f5f9');
        }
        
    } else {
        console.log("Running outside Telegram, using test mode");
        // Fallback logic is fine.
    }
};

// --- INITIALIZATION ---
const initGame = async () => {
    await loadExternalConfig();
    loadGameState();
    initTelegram();

    // Setup intervals
    setInterval(mainTick, GAME_TIMERS.MAIN_TICK);
    setInterval(saveGameState, GAME_TIMERS.SAVE_INTERVAL);

    // Setup event listeners
    document.body.addEventListener('click', (e) => {
        handleAction(e);
        const navButton = e.target.closest('[data-tab]');
        if (navButton) navigate(navButton.dataset.tab);
    });
    
    // **IMPROVEMENT**: More robust event handling for the tap button
    document.body.addEventListener('mousedown', e => { if (e.target.closest('#tapButton')) handleTap(e); });
    document.body.addEventListener('touchstart', e => { if (e.target.closest('#tapButton')) handleTap(e); }, { passive: false });

    DOM_ELEMENTS.adminToggle.addEventListener('click', () => {
        renderModal('Admin Panel', renderAdminPanelContent());
    });
    
    navigate('tap');
    updateHeader();
    DOM_ELEMENTS.loadingIndicator.style.display = 'none';
};

initGame();
});
</script>
</body>
</html>
